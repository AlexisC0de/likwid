<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>LIKWID: Intel&reg; Broadwell EP/EN/EX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LIKWID
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">LIKWID - Like I Knew What I Am Doing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Intel&reg; Broadwell EP/EN/EX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page is valid for Broadwell EP/EN/EX.</p>
<h1>Available performance monitors for the Intel&reg; Broadwell EP/EN/EX microarchitecture</h1>
<ul>
<li>
<a class="el" href="broadwellep.html#BDX_FIXED">Fixed-purpose counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_PMC">General-purpose counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_THERMAL">Thermal counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_POWER">Power measurement counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_UBOX">Uncore global counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_CBOX">Last level cache counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_BBOX">Home Agent counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_WBOX">Power control unit counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_IBOX">Coherency for IIO traffic counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_SBOX">Ring transfer counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_QBOX">Intel&reg; QPI Link Layer counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_MBOX">Integrated memory controller counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_PBOX">Ring-to-PCIe interface counters</a> </li>
<li>
<a class="el" href="broadwellep.html#BDX_RBOX">Ring-to-QPI interface counters</a> </li>
</ul>
<h1>Counters available for each hardware thread</h1>
<p><a class="anchor" id="BDX_FIXED"></a></p><h2>Fixed-purpose counters</h2>
<p>Since the Core2 microarchitecture, Intel&reg; provides a set of fixed-purpose counters. Each can measure only one specific event.</p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>FIXC0 </td><td>INSTR_RETIRED_ANY  </td></tr>
<tr>
<td>FIXC1 </td><td>CPU_CLK_UNHALTED_CORE  </td></tr>
<tr>
<td>FIXC2 </td><td>CPU_CLK_UNHALTED_REF  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Description </th><th>Comment  </th></tr>
<tr>
<td>anythread </td><td>N </td><td>Set bit 2+(index*4) in config register </td><td></td></tr>
<tr>
<td>kernel </td><td>N </td><td>Set bit (index*4) in config register </td><td></td></tr>
</table>
<p><a class="anchor" id="BDX_PMC"></a></p><h2>General-purpose counters</h2>
<p>Commonly the Intel&reg; Broadwell EP/EN/EX microarchitecture provides 4 general-purpose counters consisting of a config and a counter register.</p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>PMC0 </td><td>*  </td></tr>
<tr>
<td>PMC1 </td><td>*  </td></tr>
<tr>
<td>PMC2 </td><td>*  </td></tr>
<tr>
<td>PMC3 </td><td>*  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Description </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>kernel </td><td>N </td><td>Set bit 17 in config register </td><td></td></tr>
<tr>
<td>anythread </td><td>N </td><td>Set bit 21 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>in_transaction </td><td>N </td><td>Set bit 32 in config register </td><td>Only available if Intel&reg; Transactional Synchronization Extensions are available  </td></tr>
<tr>
<td>in_transaction_aborted </td><td>N </td><td>Set bit 33 in config register </td><td>Only counter PMC2 and only if Intel&reg; Transactional Synchronization Extensions are available  </td></tr>
</table>
<h3>Special handling for events</h3>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measureing of offcore events in PMC counters. Therefore the stream of offcore events must be filtered using the OFFCORE_RESPONSE registers. The Intel&reg; Broadwell EP/EN/EX microarchitecture has two of those registers. LIKWID defines some events that perform the filtering according to the event name. Although there are many bitmasks possible, LIKWID natively provides only the ones with response type ANY. Own filtering can be applied with the OFFCORE_RESPONSE_0_OPTIONS and OFFCORE_RESPONSE_1_OPTIONS events. Only for those events two more counter options are available:</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Description </th><th>Comment  </th></tr>
<tr>
<td>match0 </td><td>16 bit hex value </td><td>Input value masked with 0x8FFF and written to bits 0-15 in the OFFCORE_RESPONSE register </td><td>Check the <a href="http://www.Intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel&reg; Software Developer System Programming Manual, Vol. 3, Chapter Performance Monitoring</a> and <a href="https://download.01.org/perfmon/BDX">https://download.01.org/perfmon/BDX</a>.  </td></tr>
<tr>
<td>match1 </td><td>22 bit hex value </td><td>Input value is written to bits 16-37 in the OFFCORE_RESPONSE register </td><td>Check the <a href="http://www.Intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel&reg; Software Developer System Programming Manual, Vol. 3, Chapter Performance Monitoring</a> and <a href="https://download.01.org/perfmon/BDX">https://download.01.org/perfmon/BDX</a>.  </td></tr>
</table>
<p>The event MEM_TRANS_RETIRED_LOAD_LATENCY is not available because it needs programming of PEBS registers. PEBS is a kernel-level measurement facility for performance monitoring. Although we can program it from user-space, the results are always 0.</p>
<p><a class="anchor" id="BDX_THERMAL"></a></p><h2>Thermal counter</h2>
<p>The Intel&reg; Broadwell microarchitecture provides one register for the current core temperature.</p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>TMP0 </td><td>TEMP_CORE  </td></tr>
</table>
<h1>Counters available for one hardware thread per socket</h1>
<p><a class="anchor" id="BDX_POWER"></a></p><h2>Power counter</h2>
<p>The Intel&reg; Broadwell microarchitecture provides measurements of the current power consumption through the RAPL interface.</p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>PWR0 </td><td>PWR_PKG_ENERGY  </td></tr>
<tr>
<td>PWR1 </td><td>PWR_PP0_ENERGY  </td></tr>
<tr>
<td>PWR2 </td><td>PWR_PP1_ENERGY  </td></tr>
<tr>
<td>PWR3 </td><td>PWR_DRAM_ENERGY  </td></tr>
</table>
<p><a class="anchor" id="BDX_UBOX"></a></p><h2>Uncore management counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the management box in the Uncore. The description from Intel&reg;:<br />
 <em>The UBox serves as the system configuration controller for the Intel&reg; Xeon&reg; Processor E5 and E7 v4 Product Families. In this capacity, the UBox acts as the central unit for a variety of functions: </p><ul>
<li>
The master for reading and writing physically distributed registers across using the Message Channel. </li>
<li>
The UBox is the intermediary for interrupt traffic, receiving interrupts from the system and dispatching interrupts to the appropriate core. </li>
<li>
The UBox serves as the system lock master used when quiescing the platform (e.g., Intel&reg; QPI bus lock). </li>
</ul>
<p></em><br />
 The Uncore management performance counters are exposed to the operating system through the MSR interface. The name UBOX originates from the Nehalem EX Uncore monitoring where those functional units are called UBOX. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>UBOX0 </td><td>*  </td></tr>
<tr>
<td>UBOX1 </td><td>*  </td></tr>
<tr>
<td>UBOXFIX </td><td>UBOX_CLOCKTICKS  </td></tr>
</table>
<h3>Available Options (Only for UBOX&lt;0,1&gt; counters)</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Operation </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>5 bit hex value </td><td>Set bits 24-28 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
</table>
<p><a class="anchor" id="BDX_CBOX"></a></p><h2>Last level cache counters</h2>
<p>The Intel&reg; Broadwell microarchitecture provides measurements for the last level cache segments.The description from Intel&reg;:<br />
 <em>The LLC coherence engine (CBo) manages the interface between the core and the last level cache (LLC). All core transactions that access the LLC are directed from the core to a CBo via the ring interconnect. The CBo is responsible for managing data delivery from the LLC to the requesting core. It is also responsible for maintaining coherence between the cores within the socket that share the LLC; generating snoops and collecting snoop responses from the local cores when the MESIF protocol requires it. </em></p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>CBOX&lt;0-23&gt;C0 </td><td>*  </td></tr>
<tr>
<td>CBOX&lt;0-23&gt;C1 </td><td>*  </td></tr>
<tr>
<td>CBOX&lt;0-23&gt;C2 </td><td>*  </td></tr>
<tr>
<td>CBOX&lt;0-23&gt;C3 </td><td>*  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Description </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-28 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>tid </td><td>6 bit hex value </td><td>Set bits 0-5 in MSR_UNC_C&lt;0-23&gt;_PMON_BOX_FILTER register </td><td></td></tr>
<tr>
<td>state </td><td>7 bit hex value </td><td>Set bits 17-23 in MSR_UNC_C&lt;0-23&gt;_PMON_BOX_FILTER register </td><td>M': 0x40, D: 0x20, F: 0x10, M: 0x08, E: 0x04, S: 0x02, I: 0x01  </td></tr>
<tr>
<td>nid </td><td>16 bit hex value </td><td>Set bits 0-15 in MSR_UNC_C&lt;0-23&gt;_PMON_BOX_FILTER1 register </td><td>Note: Node 0 has value 0x0001  </td></tr>
<tr>
<td>opcode </td><td>9 bit hex value </td><td>Set bits 20-28 in MSR_UNC_C&lt;0-23&gt;_PMON_BOX_FILTER1 register </td><td>A list of valid opcodes can be found in the <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a>.  </td></tr>
<tr>
<td>match0 </td><td>2 bit hex address </td><td>Set bits 30-31 in MSR_UNC_C&lt;0-23&gt;_PMON_BOX_FILTER1 register </td><td>See the <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for more information.  </td></tr>
</table>
<h3>Special handling for events</h3>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides an event LLC_LOOKUP which can be filtered with the 'state' option. If no 'state' is set, LIKWID sets the state to 0x1F, the default value to measure all lookups.</p>
<p><a class="anchor" id="BDX_BBOX"></a></p><h2>Home Agent counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the Home Agent (HA) in the Uncore. The description from Intel&reg;:<br />
 <em>Each HA is responsible for the protocol side of memory interactions, including coherent and non-coherent home agent protocols (as defined in the Intel&reg; QuickPath Interconnect Specification). Additionally, the HA is responsible for ordering memory reads/writes, coming in from the modular Ring, to a given address such that the IMC (memory controller). </em><br />
 The Home Agent performance counters are exposed to the operating system through PCI interfaces. There are two of those interfaces for the HA. The name BBOX originates from the Nehalem EX Uncore monitoring where this functional unit is called BBOX. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>BBOX&lt;0,1&gt;C0 </td><td>*  </td></tr>
<tr>
<td>BBOX&lt;0,1&gt;C1 </td><td>*  </td></tr>
<tr>
<td>BBOX&lt;0,1&gt;C2 </td><td>*  </td></tr>
<tr>
<td>BBOX&lt;0,1&gt;C3 </td><td>*  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Description </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>opcode </td><td>6 bit hex value </td><td>Set bits 0-5 in PCI_UNC_HA_PMON_OPCODEMATCH register of PCI device </td><td></td></tr>
<tr>
<td>match0 </td><td>46 bit hex address </td><td>Extract bits 6-31 and set bits 6-31 in PCI_UNC_HA_PMON_ADDRMATCH0 register of PCI device<br />
Extract bits 32-45 and set bits 0-13 in PCI_UNC_HA_PMON_ADDRMATCH1 register of PCI device </td><td></td></tr>
</table>
<p><a class="anchor" id="BDX_WBOX"></a></p><h2>Power control unit counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the power control unit (PCU) in the Uncore. The description from Intel&reg;:<br />
 <em>The PCU is the primary Power Controller for the Intel&reg; Xeon&reg; Processor E5 and E7 v4 Product Families.<br />
 The uncore implements a power control unit acting as a core/uncore power and thermal manager. It runs its firmware on an internal microcontroller and coordinates the socket’s power states. </em><br />
 The PCU performance counters are exposed to the operating system through the MSR interface. The name WBOX originates from the Nehalem EX Uncore monitoring where those functional units are called WBOX. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>WBOX0 </td><td>*  </td></tr>
<tr>
<td>WBOX1 </td><td>*  </td></tr>
<tr>
<td>WBOX2 </td><td>*  </td></tr>
<tr>
<td>WBOX3 </td><td>*  </td></tr>
<tr>
<td>WBOX0FIX </td><td>CORES_IN_C3  </td></tr>
<tr>
<td>WBOX1FIX </td><td>CORES_IN_C6  </td></tr>
</table>
<h3>Available Options (Only for WBOX&lt;0-3&gt; counters)</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Operation </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>5 bit hex value </td><td>Set bits 24-28 in config register </td><td></td></tr>
<tr>
<td>occupancy </td><td>2 bit hex value </td><td>Set bit 14-15 in config register </td><td>Cores in C0: 0x1, in C3: 0x2, in C6: 0x3  </td></tr>
<tr>
<td>occupancy_filter </td><td>32 bit hex value </td><td>Set bits 0-31 in MSR_UNC_PCU_PMON_BOX_FILTER register </td><td>Band0: bits 0-7, Band1: bits 8-15, Band2: bits 16-23, Band3: bits 24-31  </td></tr>
<tr>
<td>occupancy_edgedetect </td><td>N </td><td>Set bit 31 in config register </td><td></td></tr>
<tr>
<td>occupancy_invert </td><td>N </td><td>Set bit 30 in config register </td><td></td></tr>
</table>
<p><a class="anchor" id="BDX_IBOX"></a></p><h2>IRP box counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the IRP box in the Uncore. The description from Intel&reg;:<br />
 <em>IRP is responsible for maintaining coherency for IIO traffic that needs to be coherent (e.g. cross-socket P2P). </em> The IRP box counters are exposed to the operating system through the PCI interface. The IBOX was introduced with the Intel&reg; IvyBridge EP/EN/EX microarchitecture. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>IBOX&lt;0,1&gt;C0 </td><td>*  </td></tr>
<tr>
<td>IBOX&lt;0,1&gt;C1 </td><td>*  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Operation </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
</table>
<p><a class="anchor" id="BDX_MBOX"></a></p><h2>Memory controller counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the integrated Memory Controllers (iMC) in the Uncore. The description from Intel&reg;:<br />
 <em>The Intel&reg; Xeon&reg; Processor E5 and E7 v4 Product Families integrated Memory Controller provides the interface to DRAM and communicates to the rest of the Uncore through the Home Agent (i.e. the IMC does not connect to the Ring). <br />
 In conjunction with the HA, the memory controller also provides a variety of RAS features, such as ECC, lockstep, memory access retry, memory scrubbing, thermal throttling, mirroring, and rank sparing. </em><br />
 The integrated Memory Controllers performance counters are exposed to the operating system through PCI interfaces. There may be two memory controllers in the system. There are 4 different PCI devices per memory controller, each handling 4 memory channels. Each channel has 4 different general-purpose counters and one fixed counter for the DRAM clock. The channels of the first memory controller are MBOX0-3, the four channels of the second memory controller (if available) are named MBOX4-7. The name MBOX originates from the Nehalem EX Uncore monitoring where those functional units are called MBOX. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>MBOX&lt;0-7&gt;C0 </td><td>*  </td></tr>
<tr>
<td>MBOX&lt;0-7&gt;C1 </td><td>*  </td></tr>
<tr>
<td>MBOX&lt;0-7&gt;C2 </td><td>*  </td></tr>
<tr>
<td>MBOX&lt;0-7&gt;C3 </td><td>*  </td></tr>
<tr>
<td>MBOX&lt;0-7&gt;FIX </td><td>DRAM_CLOCKTICKS  </td></tr>
</table>
<h3>Available Options (Only for counter MBOX&lt;0-7&gt;C&lt;0-3&gt;)</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Operation </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
</table>
<p>Although the fixed-purpose registers (MBOX&lt;0-7&gt;FIX) have a bit to invert the counting stategy, it is not supported by LIKWID because the corresponding threshold bit range is missing. The documentation lists the invert bit but no threshold bit range.</p>
<p><a class="anchor" id="BDX_PBOX"></a></p><h2>Ring-to-PCIe counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the Ring-to-PCIe (R2PCIe) interface in the Uncore. The description from Intel&reg;:<br />
 <em>R2PCIe represents the interface between the Ring and IIO traffic to/from PCIe.</em><br />
 The Ring-to-PCIe performance counters are exposed to the operating system through a PCI interface. Independent of the system's configuration, there is only one Ring-to-PCIe interface per CPU socket. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>PBOX0 </td><td>*  </td></tr>
<tr>
<td>PBOX1 </td><td>*  </td></tr>
<tr>
<td>PBOX2 </td><td>*  </td></tr>
<tr>
<td>PBOX3 </td><td>*  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Operation </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
</table>
<p><a class="anchor" id="BDX_SBOX"></a></p><h2>Ring-to-Ring interface counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture manages the socket internal traffic through ring-based networks. Depending on the system's configuration there are multiple rings in one socket. The SBOXes organizes the traffic between the rings. The description from Intel&reg;:<br />
 <em>The SBox manages the interface between the two Rings.<br />
 The processor is composed of two independent rings connected via two sets of bidirectional buffered switches. Each set of bidirectional buffered switches is partitioned into two ingress/egress pairs. Further, each ingress/egress pair is associated with a ring stop on adjacent rings. This ring stop is termed an Sbo. The processor has up to 4 SBos depending on SKU. The Sbo can be simply thought of as a conduit for the ring, but must also help maintain ordering of traffic to ensure functional correctness in certain cases. </em><br />
 The SBOX hardware performance counters are exposed to the operating system through the MSR interface. There are maximal four of those interfaces but not all must be present. The name SBOX originates from the Nehalem EX Uncore monitoring where the functional unit to the QPI network is called SBOX but it had a different duty.. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>SBOX&lt;0-3&gt;C0 </td><td>*  </td></tr>
<tr>
<td>SBOX&lt;0-3&gt;C1 </td><td>*  </td></tr>
<tr>
<td>SBOX&lt;0-3&gt;C2 </td><td>*  </td></tr>
<tr>
<td>SBOX&lt;0-3&gt;C3 </td><td>*  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Description </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>tid </td><td>N </td><td>Set bit 19 in config register </td><td>This option has no real effect because TID filtering can be activated but there is no possibility to specify the TID somewhere.  </td></tr>
</table>
<p><a class="anchor" id="BDX_QBOX"></a></p><h2>QPI interface counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the QPI Link layer (QPI) in the Uncore. The description from Intel&reg;:<br />
 <em>The Intel&reg; QPI Link Layer is responsible for packeting requests from the caching agent on the way out to the system interface. As such, it shares responsibility with the CBo(s) as the Intel QPI caching agent(s). It is responsible for converting CBo requests to Intel QPI messages (i.e. snoop generation and data response messages from the snoop response) as well as converting/forwarding ring messages to Intel QPI packets and vice versa.<br />
 On Intel&reg; Xeon&reg; Processor E5 and E7 v4 Product Families, Intel&reg; QPI is split into two separate layers. The Intel&reg; QPI LL (link layer) is responsible for generating, transmitting, and receiving packets with the Intel&reg; QPI link.<br />
 R3QPI (<a class="el" href="broadwellep.html#BDX_RBOX">BDX_RBOX</a>) provides the interface to the Ring for the Link Layer. It is also the point where VNA/VN0 link credits are acquired. </em><br />
 The QPI hardware performance counters are exposed to the operating system through PCI interfaces. There are two of those interfaces for the QPI. The actual amount of QBOX counters depend on the CPU core count of one socket. If your system has not all interfaces but interface 0 does not work, try the other ones. The QBOX was introduced for the Broadwell EP microarchitecture, for older Uncore-aware architectures the QBOX and the SBOX are the same. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>QBOX&lt;0-2&gt;C0 </td><td>*  </td></tr>
<tr>
<td>QBOX&lt;0-2&gt;C1 </td><td>*  </td></tr>
<tr>
<td>QBOX&lt;0-2&gt;C2 </td><td>*  </td></tr>
<tr>
<td>QBOX&lt;0-2&gt;C3 </td><td>*  </td></tr>
<tr>
<td>QBOX&lt;0-2&gt;FIX0 </td><td>QPI_RATE  </td></tr>
<tr>
<td>QBOX&lt;0-2&gt;FIX1 </td><td>QPI_RX_IDLE  </td></tr>
<tr>
<td>QBOX&lt;0-2&gt;FIX2 </td><td>QPI_RX_LLR  </td></tr>
</table>
<h3>Available Options (Only for QBOX&lt;0-2&gt;C&lt;0,1,2,3&gt; counters)</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Description </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
<tr>
<td>match0 </td><td>32 bit hex address </td><td>Input value masked with 0x8003FFF8 and written to bits 0-31 in the Q_Py_PCI_PMON_RX_PKT_MATCH0 register of PCI device </td><td>This option matches the receive side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
<tr>
<td>match1 </td><td>20 bit hex address </td><td>Input value masked with 0x000F000F and written to bits 0-19 in the Q_Py_PCI_PMON_RX_PKT_MATCH1 register of PCI device </td><td>This option matches the receive side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
<tr>
<td>match2 </td><td>32 bit hex address </td><td>Input value masked with 0x8003FFF8 and written to bits 0-31 in the Q_Py_PCI_PMON_TX_PKT_MATCH0 register of PCI device </td><td>This option matches the transmit side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
<tr>
<td>match3 </td><td>20 bit hex address </td><td>Input value masked with 0x000F000F and written to bits 0-19 in the Q_Py_PCI_PMON_TX_PKT_MATCH1 register of PCI device </td><td>This option matches the transmit side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
<tr>
<td>mask0 </td><td>32 bit hex address </td><td>Input value masked with 0x8003FFF8 and written to bits 0-31 in the Q_Py_PCI_PMON_RX_PKT_MASK0 register of PCI device </td><td>This option masks the receive side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
<tr>
<td>mask1 </td><td>20 bit hex address </td><td>Input value masked with 0x000F000F and written to bits 0-19 in the Q_Py_PCI_PMON_RX_PKT_MASK1 register of PCI device </td><td>This option masks the receive side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
<tr>
<td>mask2 </td><td>32 bit hex address </td><td>Input value masked with 0x8003FFF8 and written to bits 0-31 in the Q_Py_PCI_PMON_TX_PKT_MASK0 register of PCI device </td><td>This option masks the transmit side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
<tr>
<td>mask3 </td><td>20 bit hex address </td><td>Input value masked with 0x000F000F and written to bits 0-19 in the Q_Py_PCI_PMON_TX_PKT_MASK1 register of PCI device </td><td>This option masks the transmit side. Check <a href="http://www.intel.ie/content/www/ie/en/processors/xeon/xeon-e5-v4-uncore-performance-monitoring.html">Intel&reg; Xeon E5 v4 Uncore Manual</a> for bit fields.  </td></tr>
</table>
<p><a class="anchor" id="BDX_RBOX"></a></p><h2>Ring-to-QPI counters</h2>
<p>The Intel&reg; Broadwell EP/EN/EX microarchitecture provides measurements of the Ring-to-QPI (R3QPI) interface in the Uncore. The description from Intel&reg;:<br />
 <em>R3QPI is the interface between the Intel&reg; QPI Link Layer, which packetizes requests, and the Ring.<br />
 R3QPI is the interface between the ring and the Intel&reg; QPI Link Layer. It is responsible for translating between ring protocol packets and flits that are used for transmitting data across the Intel&reg; QPI interface. It performs credit checking between the local Intel&reg; QPI LL, the remote Intel&reg; QPI LL and other agents on the local ring.</em></p>
<p><em></em><br />
 The Ring-to-QPI performance counters are exposed to the operating system through PCI interfaces. Since the RBOXes manage the traffic from the LLC-connecting ring interface on the socket with the QPI interfaces (SBOXes), the amount is similar to the amount of SBOXes. See at SBOXes how many are available for which system configuration. The name RBOX originates from the Nehalem EX Uncore monitoring where those functional units are called RBOX. </p>
<h3>Counter and events</h3>
<table class="doxtable">
<tr>
<th>Counter name </th><th>Event name  </th></tr>
<tr>
<td>RBOX&lt;0,1,2&gt;C0 </td><td>*  </td></tr>
<tr>
<td>RBOX&lt;0,1,2&gt;C1 </td><td>*  </td></tr>
<tr>
<td>RBOX&lt;0,1,2&gt;C2 </td><td>*  </td></tr>
</table>
<h3>Available Options</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Argument </th><th>Operation </th><th>Comment  </th></tr>
<tr>
<td>edgedetect </td><td>N </td><td>Set bit 18 in config register </td><td></td></tr>
<tr>
<td>invert </td><td>N </td><td>Set bit 23 in config register </td><td></td></tr>
<tr>
<td>threshold </td><td>8 bit hex value </td><td>Set bits 24-31 in config register </td><td></td></tr>
</table>
<p>*/ </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 19 2018 16:37:05 for LIKWID by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
